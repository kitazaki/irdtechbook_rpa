= 現場で使えるPython自動化入門

//flushright{
青木 敬樹
//}

== はじめに

これを手に取られた方は実務で使用する自動化に興味がある方でしょうか？この章はPython自動化入門としています。しかし、一般書でも様々な自動化の手法やライブラリの紹介が豊富にされています。そのため本章では、Pythonを実務で使用した際の私の経験に基づくTipsを詰め込みたいと思います。Python限定の話もありますが、言語に特定されず別のもので読み変えていただく事もできると思います。本章は

 1. 頭をすっきりテスト駆動開発
 2. みんなで読もうSphinx
 3. 最後の救いlog取得

の3つで構成されています。

== 頭をすっきりテスト駆動開発

=== はじめに 

皆さんはテスト駆動開発という言葉をご存知でしょうか？アジャイル開発で有名なこちらのメソッド、提唱したのはKent Beckです。

まず初めにテスト駆動開発を知る前のこのメソッドに対するイメージは「面倒くさそう」というものでした。これは個人開発程度であればテストという行為そのものが必要ではなかった為であり、また成果物の品質を担保するためのテストとテスト駆動開発を混同していた為です。そのため開発後の工程を取り入れる必要性が判りませんでした。しかし、今ではその恩恵にあずかっておりそのイメージは「多少手間はかかるが便利で有効」と変わっています。この説ではテスト駆動のメリットとその手法の紹介を行ないたいと思います。

=== テスト駆動とは？

まずテスト駆動開発自体の紹介を行なう前に、始めに私がなぜテスト駆動開発を必要としたのかの背景を説明したいと思います。皆さんの中で近しい状況があればこの節を読み進めるモチベーションになりますし、逆に読み飛ばす判断材料にもなると思います。（もちろん、是非読んでいただきたい所ですが。。。笑）

事の始まりは業務自動化用のスクリプトを書いている所からでした。以下のような出力された文字列情報を解析して異常がないか確認するためのスクリプトです。

//image[07_001][解析対象例]

さらっと書けてしまいそうですが、上記の図のような物を判定するときいくつも考えなければならない事があります。
例えば、

 * 入力が想定外の物だったら？
 * 予期せぬ内容だったら？
 * 条件分岐はあってる？（組み合わせに問題はない？）
 * 型変換時ミスはしていない？

とくにPythonのように型を明示的に指定しない言語では比較的潜在する想定外のバグが増えやすい傾向にあると思います。もちろん一つずつ抜け漏れなく考えることができれば問題はありません。しかし気をつける事が多いため、実装している間は複雑なイライラ棒をしているような気持ちになりました。さらに弊害として１つの機能を実装するだけでも疲れてしまい、中々思うように開発も進まずフラストレーションのたまる日々でした。

ここまで背景をお話ししましたが、この悩み要約すると

 * 沢山注意しながら開発をするのが大変

となると思います。この悩みを解決するのがテスト駆動開発でした。

テスト駆動開発のステップ@<fn>{fn-0701}はKent Beckによると

 1. まずテストを1つ書く
 2. すべてのテストを走らせ、すべて成功することを確認する
 3. 小さな変更を行う
 4. すべてのテストを走らせ、全て成功することを確認する
 5. リファクタリングを行なって重複を除去する

とされています。

//footnote[fn-0701][Kent Beck（2017）『テスト駆動開発』和田 卓人訳, P1, オーム社.]

ここでの大きなポイントはまずテストを書くという事です。小さく機能を開発しテストを実施するというステップを繰り返せば、ミスをした瞬間にテストが指摘してくれます。始めはテストに引っかかるたびに小言を言われているような気がして億劫でしたが、機能の実装を完了してみると思ったよりも時間がかかっておらず疲れも少なかった事を今でも覚えています。これは頭のリソースを機能開発にだけ使う事ができ、バグへの懸念はテストに指摘されたタイミングで修正するだけで良いというのが理由だと考えています。もちろん小さなスクリプトであればテストを最初に書くため書かない場合より時間がかかることは否めません。しかしそのコードが長くなればなるほど複雑さが増すため、頭のリソースを機能開発にだけ向けることができるテスト駆動開発の方が、効率が上がり開発時間が短くなる可能性があります。テスト駆動開発は言わば長距離走向けの手法と言えるでしょう。

あくまで私の体験談でサンプル１のお話でしたが、ここまでテスト駆動開発が広まっている事を考えると試す価値はあると思います。この説ではテスト駆動開発の紹介のみにとどまりますが興味を持たれた方は、Kent Beckの「テスト駆動開発」もしくはRobert C MartinのClean Code 第5章を参考にしてみてください。

=== 誰が為のテスト駆動？

さてここまで素晴らしい手法としてテスト駆動開発として説明してきましたが、私はテスト駆動開発は常に使うべきとは考えていません。理由としてはPJで開発する以外の場面ではテストを成果としづらいと考えている為です。もちろん、チーム内でテストを残す文化があれば別ですが、チームで成果と見なされないものに工数を掛ける行為は中々継続しないものです。

そもそもの話となりますが、テスト駆動開発で作成するテストと品質の為のテストでは目的が異なります。テスト駆動開発で書くテストは開発者の注意点を網羅していれば良く、カバレッジをそこまで意識しなくても問題はないと思われます。品質担保の為の成果物としてテストを残す為にはカバレッジを上げる必要がありますが、そのカバレッジ向上と成果物の品質の向上は対数曲線的な関係にあると考えており幾ら細かいバグをテストしていてもスクリプトの機能自体は向上しません。

趣味ではなく現場で活用することを考えると工数も切り離せないファクターの一つです。成果に対して労力を必要以上にかける事は無駄であると考えて割り切ることは必要だと考えています。逆に言えば、ある程度品質が求められるのであればそれなりの工数が必要となる為、テストする工程を別で考えた方が良いと思います。

以上の事から、私は求められる品質を考慮したうえで開発の為のメソッドの一つとして効率を上げる為だけに利用する事を心掛けています。

== みんなで読もうSphinx

=== はじめに  

いきなりで恐縮ですが、ツールを作成する事の恩恵は自分で使う場合のみにとどまらないと考えています。そしてむしろその多くは他の方に使ってもらう事により得られるものだと思っています。もちろんツールの種別によるとは思いますが、適切に抽象化されたメソッドは他の人に利用、継承してもらう事で複利的にその真価を発揮し続けます。

しかし、このような文化を形成していくためには誰かにその仕様を適切に伝える必要があります。そのためにはドキュメントが必要となるでしょう。皆さんはツールを作成するときにどのようなドキュメントを作成していますか？ReadME.mdを作成する、エクセルで作成する、テキストで作成するなど様々だと思います。

本節ではドキュメントを作成する為に、Sphinxというドキュメントジェネレータをご紹介したいと思います。

ドキュメントジェネレータとはその名の通りドキュメントを作成するためのツールです。百聞は一見にしかずという事で、まずはSphinxの活用事例を見てみましょう。以下はOpen3Dという点群処理用のライブラリのドキュメント@<fn>{fn-0702}です。

//footnote[fn-0702][http://www.open3d.org/docs/release/tutorial/geometry/pointcloud.html]

見ていただくとわかる通りhtml形式のwebサイトのようなドキュメントです。

//image[07_002][Open3Dドキュメント]

一言で言ってしまえば、Sphinxはこのhtmlドキュメントを作成するためのツールです。（もちろん、htmlに限らずLatexやePub, Texinfo, manual pages, plain texといったフォーマットにも対応しています。@<fn>{fn-0703}）類似のツールとしてはDoxygenなどが有名です。

//footnote[fn-0703][https://www.sphinx-doc.org/ja/master/]

Sphinxのようなドキュメント生成ツールでドキュメントを作成した場合のメリットをいくつか列挙してみると、

 1. ドキュメントがきれい
 2. コメントが残る
 3. 検索ができる
 4. レイアウトを統一しやすい

といったところでしょうか。

まずドキュメントが綺麗である事は明白です。ただのテキストよりはこちらの方が読みやすいです。次にコメントが残るという点について、詳しくは後述しますが、実はこのSphinxで生成する為のドキュメントの情報はプログラムにコメントとして残すのです。またプログラムにコメントとして残されている為に、テキストとして残ることもメリットとなると思います。エンジニアとしてはデータをなるべく環境に依存しない方法で記載をしたいものです。この点においてプログラムのコメントとして残っていれば安心です。

さらに、このSphinxでは検索機能もついてきます。ユーザーフレンドリーなUIがあれば他の方にも使ってもらいやすいです。最後にレイアウトを統一しやすいという点も上げられます。いろんな方がテキストでドキュメントを作成するとそのレイアウトは多種多様になりその読みやすさも書き手によってまちまちになります。

最終的にドキュメントの質はその内容に依存しますが、レイアウトが整えられている事で読み手はコンテキストを把握しやすくなるためレイアウトを統一しておく方がベターだと思います。

=== Sphinx入門

Sphinxのドキュメント生成方法の基本的なステップは以下のとおりです。

 1. コメントを記載する
 2. rstファイルを生成する
 3. ドキュメントを生成する

ここからは、実際にSphinxでドキュメントを生成する流れをご紹介します。

Sphinxはまずコメントを書きます。今回はGoogleのDocstring形式@<fn>{fn-0704}で記述します。このほか、numpy形式などもあるのでお好みのスタイルを使いましょう。

//footnote[fn-0704][https://google.github.io/styleguide/pyguide.html 3.8.2 Modules]

＜test.py(Google Docstring形式コメント入り)＞

//emlist{
class test:
    """
    testメソッド
    """
    def __init__(self, n):
        self.number = n
    
    def add(self, a):
        """
        内部変数nにaを足す関数

        Args:
            a(int): 内部変数nにaを足す

        Returns:
            int : 足し算後の内部変数
        """
        self.number += a
        return self.number
    
    def out(self):
        """
        内部変数を出力するだけの関数

        Returns:
            None
        """
        print(self.number)
//}

次にコメントからreStructuredText（rstファイル）を作成後、ドキュメントを生成します。環境依存のあるconfigの記述など詳細部分は省きましたが、ほぼこれだけで以下のようなドキュメントが生成されます。

//image[07_003][ドキュメント例]

また、Sphinxではhtmlテーマがいくつもある為、自分好みに様々なカスタマイズを行なう事ができます。以下でいくつかのテーマを紹介いたします。（個人的にはOpen3Dでも使用されているサードパーティー製のRead the Docsが好みです。）

//image[07_004][classic]
//image[07_005][Alabaster]
//image[07_006][Read the Docs]

=== 型アノテーションのすすめ

さて少しSphinxとは離れますが、コードに仕様を記載するという点で型アノテーションについてご紹介したいと思います。型アノテーションはPython3.5から追加された機能でPythonの引数の型と返り値の型を記述する方法です。あくまでもアノテーションの為Python自体の挙動には関係がありません。以下にアノテーションの例を示します。

例えばaddメソッドには引数の隣にint型と記載してあり、返り値の型は”->”で記述されています。詳しくはPython.orgのドキュメントを参照ください。@<fn>{fn-0705}

//footnote[fn-0705][https://docs.python.org/ja/3/library/typing.html]

＜test.py＞

//emlist{
class test:
    def __init__(self, n:int):
        self.number = n
    
    def add(self, a:int) -> int:
        self.number += a
        return self.number
    
    def out(self) -> None:
        print(self.number)
//}

型アノテーションはPythonで定義されている為、通常のコメントとは異なりIDEなどを使うと自動で読み取ってくれる場合もあります。例えばVisual Studio Codeでadd関数を呼び出すと以下のように型ヒントを自動で示してくれます。

//image[07_007][Visual Studio Codeによる型ヒント]

その他サードパーティーライブラリのmypy@<fn>{fn-0706}などを使用すると、型ヒントから型チェックを行なう事ができます。例えば以下のように、intで定義した変数に対して文字列を代入するようなコードを書いたとします。ここで実行すると後から代入した文字列が表示されます。

//footnote[fn-0706][https://github.com/python/mypy]

しかし、mypyを実行すると以下のようにエラーが出力されます。エラー文を読むと2行目で定義されている型と一致しないという事のようです。C言語等のコンパイルチェックのようですね。これにより事前の型チェックを行なう事ができるようになり、型誤りによるバグの混入を未然に防ぐことができます。

＜mypy_usecase.py＞

//emlist{
def main():
    a: int = 3
    a = "bug"
    print(a)

if __name__ == '__main__':
    main()
//}

＜実行結果＞

//emlist{
bug
//}

<mypy実行結果>

//emlist{
(huga)hoge@hogehoge $ mypy mypy_usecase.py
mypy_usecase.py:2: error: Incompatible types in assignment (expression has type "str", variable has type "int")  [assignment]
Found 1 error in 1 file (checked 1 source file)
//}

=== 現場での活用方法

現場で使用する場合には、生成されたドキュメント群を共有ディレクトリに置いています。エクスプローラーでパスがたどれるのであればドキュメント用に新規でサーバーを建てずともブラウザから確認することが可能です。

== 最後の救いlog取得

=== はじめに   

みなさんはlogを残しているでしょうか？先ほどの「2.1 はじめに」で述べたように私はなるべく多くの方に使ってもらう事でツールは真価を発揮し続けるという考えをもっています。沢山の方が使えば使うほど想定外の問題が起きる可能性は上がります。仕様による動作から想定しないバグまでできる事であれば全て網羅したいところですが、ツール作成時には必要以上の仕様を入れ込むことはコストパフォーマンスの低下を招きます。また、必要でない機能は仕様を決める時の解像度が低い為、良い仕様にすることは難しいものです。

そこでツール使用者に適切な情報を与えるためにlog機能が必要になってきます。本節では、ツールの使用者に適切な情報を与えるためのlogについてお話ししたいと思います。

=== logを設定しよう

まず、前提としてどのようなlogが必要となるでしょうか？これは目的によって様々となります。例えばレポートログを作成するツールであれば形式は人が読みやすい書式が良いでしょう。今回はツールのデバッグ用のログとして考えてみましょう。

ログにはロギングレベルというものがあります。例えばPythonのloggingモジュールでは以下の6つが定義されています。@<fn>{fn-0707}

//footnote[fn-0707][https://docs.python.org/ja/3/library/logging.html?highlight=log]

 * CRITICAL
 * ERROR
 * WARNING
 * INFO
 * DEBUG
 * NOTSET

なぜこんなにも分れているかというと、常に出してほしい情報と必要な時に出してほしい情報のレベルは異なる為です。

例えば、セキュリティソフトをイメージしてみましょう。デバッグ用に必要な情報はなるべく多く出したいものですが、常に今どのファイルを検査していて、どのようなアップデートファイルをインストールしていて、バックグラウンドでどのシステムが動いているといった通知が常に出ていると必要な情報が埋もれてしまい逆に判りづらくなってしまいます。

一方で、攻撃を受けた場合は即座に通知をしてほしいものです。このように、その必要性に応じて適切にロギングレベルを適切に管理する必要があります。これだけの種類が用意されているとはいえ私が現場で使う際はCRITICAL、WARNING、DEBUG程度でしか使い分けをしていません。理由としてはPythonで作成するツールの多くはそこまで規模が大きくならない為です。粒度は必要に応じて定めてよいと思います。

Pythonであれば、loggingモジュールで必要なレベルを設定しておけばimport先でloggingモジュールを使っていればlogに情報が吐き出されます。適切に設定しておくことでユーザーフレンドリーなツールとなるでしょう。また使用者側で確認ができればツールから手を離すことができます。現場ではツール開発者がメンテナンスを行なうことも多いと思います。ログを残してなるべく使用者側の手で解決してもらえるようにしておくと良いと思います。

=== DEBUGはDEBUG

DEBUGログはバグ調査の最後の手段としてあるべきだと考えています。そのため、なるべくDEBUGでは様々な情報があったほうが良いのですが、それでも必要な情報は精査すべきです。

これは、私自身の体験なのですが何度も呼び出されるモジュールに対して細かくDEBUGを吐き出すように設定していました。何度かテストを行なってログを確認しようとするとテキストエディタでは開けなくなってしまいました。これは、あまりにもログを細かく設定しすぎたために一度の呼び出しで沢山のログが吐き出され（一度で約500MB程度）いつの間にかログが肥大化していたためです。DEBUGの設定はデバッグの為に必要な情報を精査すべきでした。

この例は、あくまでも私の場合であり状況に応じてログを残すべきですが、サーバー上に置くものであればログがディスクの圧迫を招く可能性があるという事も考慮に入れるべきでしょう。また事前にログの量をある程度見積もることも重要だと思います。

== さいごに

本章の裏テーマは「開発者の負担を減らす」というものでした。Pythonでは様々なモジュールがでており、また書籍やテックブログも潤沢である事でツールを開発しやすくなっていると思います。

一方で現場ではその多くが開発者自身で運用やメンテナンスにも時間をさく必要があり、ツールを開発すればするだけメンテナンスコストが高まるという負のサイクルに課題を感じています。そのため本章の2/3がツール利用者に自力で解決してもらう為の同線を敷く為のTipsとなっています。ご紹介した内容が少しでも有益なものとなれば幸いです。本章をお読みいただきありがとうございました。
